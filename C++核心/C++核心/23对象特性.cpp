#include <iostream>
using namespace std;


//构造函数：对象实例化时自动调用的，一般用于初始化。若没写编译器会自动生成一个空的构造函数。
//构造函数没有返回值（不要写Void）,函数名和类名一致，有参数、可以重载

//析构函数：对象销毁时自动调用的，函数名为~类名，无参数、无重载。若没写编译器会自动生成一个空的析构函数。

//若没写，编译器会自动生成 构造函数，拷贝构造函数，析构函数 3个函数	
//但是若写了拷贝构造函数，那么不会生成默认构造函数（所以一定要带对象了）
//若写了有参数构造函数，就不会生成无参的（所以实例化就一定要带参数了）
//自动生成的拷贝构造函数会将传入的对象公共成员属性复制到新对象上，但是只会做浅拷贝（指针时就仅仅将指针拷贝）,
//若有delete释放内存的析构函数，会导致同一地址多次释放
//解决方法：自己定义拷贝构造函数，实现深拷贝（把指针对应的值，新建空间来储存）


class Test
{
public:
	Test() {
		cout << "无参构造函数" << endl;
	}
	Test(int n, int nn) {
		a = n;
		b = n;
		cout << "有参构造函数n=" << n << endl;

		int* p = new int(nn);
	}
	// 使用初始化列表，快速构造
	Test(int n1, int n2, int n3) : a(n1), b(n2), c(n3)
	{
		cout << "初始化列表形式的构造函数！" << endl;
	}
	/*
	拷贝构造函数的使用：
	1. 使用一个已经创建完毕的对象来初始化新对象
	2. 值传递的方式给函数参数传值
	3. 值方式返回局部对象
	*/
	Test(const Test &obj) { // 拷贝构造函数要求传入同类对象的 const 的引用
		a = obj.a;
		b = obj.b;
		cout << "拷贝构造函数，一般用于将同类的另一个对象的值赋给新对象" << endl;
	}
	~Test() {
		if (p != NULL)
		{
			delete p;
			p = NULL; // 防止多次delete
		}
		cout << "析构函数" << endl;
	}

private:
	int a;
	int b;
	int c;
	int* p;
};


void func_23_test(Test t) {

}

Test func_23_test2() {
	Test t;
	return t;
}


void func_23() {
	//Test t1; // 注意若没有参数不能加括号，否则会被解析成函数生命
	//Test t2(666); //同 Test t2 = Test(666);
	//Test t3(t2);

	//Test(666); //匿名对象,不能用拷贝构造函数来初始化匿名对象 如: Test(t2); //编译器会视为 Test t2;

	//Test t4 = 666; // 隐式转化法
	//Test t5 = t2;

	//func_23_test(t2); //2. 值传递的方式给函数参数传值，实参复制为形参时，会触发新的拷贝构造函数
	//Test t6 = func_23_test2(); //3. 值方式返回局部对象,因为函数返回的是返回值拷贝的副本

	Test t(666, 123);
	Test t(1, 2, 3);
}
